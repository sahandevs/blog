<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link href="https://fonts.googleapis.com/css?family=Source Code Pro" rel="stylesheet"/><style data-href="/styles.41c365c0c993c6df84a7.css" data-identity="gatsby-global-css">:root{--lr-padding:10px;--border-radius:8px;--primary-color-active:#ff7e14;--primary-color-inactive:#ffd1ac;--secondary-color:#fffcf9;--anim-duration:300ms;--paragraph-width:calc(min(760px, 100%));--code-width:min(100%,calc(var(--paragraph-width) + 12%));--paragraph-padding:calc(var(--code-width)/2 - var(--paragraph-width)/2);font-size:16px}.footnotes,.main-container h1,.text,a,em,h2,h3,h4,h5,h6,li,p,ul{direction:rtl;font-family:Vazir,monospace,Source Code Pro!important;line-height:1.6}.main-container h1,h2,h3,h4,h5,h6{padding-left:var(--paragraph-padding);padding-right:var(--paragraph-padding)}.text a{overflow-wrap:anywhere}.footnotes li{color:#5c6e74;font-size:.8rem!important}.main-container-wrapper{align-items:center;display:flex;flex-direction:column;width:100%}.main-container p{margin:0}a{text-decoration:none}a,a:hover{color:var(--primary-color-active)}a:hover{text-decoration:underline}.main-container{padding-top:1rem;width:var(--code-width)}.main-container img{display:block;margin-left:auto;margin-right:auto;max-height:500px;max-width:80%}.main-container .img-container{max-width:100%}@media screen and (max-width:768px){:root{--lr-padding:10%}}@media screen and (max-width:375px){:root{--lr-padding:5%}.main-container{margin-top:0;padding-top:0!important}.main-container h1{margin-top:10px}.main-container blockquote{margin:25px 0 0}.main-container img{max-width:100%;vertical-align:top}.main-container .img-container{overflow-x:auto}}.main-container li{font-size:1.2rem;margin-left:var(--paragraph-padding);margin-right:var(--paragraph-padding);margin-top:.6rem;padding:0;text-align:justify}.main-container p,.text{font-size:1.2rem;padding-left:var(--paragraph-padding);padding-right:var(--paragraph-padding);text-align:justify}.main-container blockquote .text{--h-space:10px;--v-space:4px;background-color:#e7e7e7;border-radius:var(--border-radius);border-right:5px solid var(--primary-color-inactive);margin-left:calc(var(--paragraph-padding)*1.3);margin-right:calc(var(--paragraph-padding)*1.3);padding:var(--v-space) var(--h-space);transition:border-right var(--anim-duration)}.main-container blockquote .text:hover{border-right-color:var(--primary-color-active)}.resources .text{direction:ltr;font-size:.8rem;text-align:start}.main-container code{background-color:#f1f1f1;border-radius:var(--border-radius);direction:ltr!important;font-size:1.1rem;padding-left:6px;padding-right:6px;text-align:left;white-space:nowrap}.playground-button{background-color:var(--primary-color-active);border-bottom-left-radius:var(--border-radius);padding:0 5px;position:absolute;right:0;top:0}.playground-button a{color:#fff;font-size:.8rem;margin:0}.playground-button a:hover{text-decoration:none}code[class*=language-],pre[class*=language-]{color:#5c6e74;direction:ltr;font-family:Source Code Pro,Andale Mono,Ubuntu Mono,monospace;font-size:1rem;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;text-shadow:none;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-]::mozselection,code[class*=language-]::selection,pre[class*=language-]::mozselection,pre[class*=language-]::selection{background:#b3d4fc;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{background:var(--secondary-color);border:1px solid var(--primary-color-inactive);border-radius:var(--border-radius);margin:.5em 0;overflow:auto;padding:.8em;transition:border var(--anim-duration)}pre[class*=language-]:hover{border:1px solid var(--primary-color-active)}:not(pre)>code[class*=language-]{background:#f9f2f4;border-radius:.3em;color:#db4c69;padding:.1em .3em}.namespace{opacity:.7}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#999}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{background:#fff;color:#a67f59}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}pre[data-line]{position:relative}pre[class*=language-]>code[class*=language-]{position:relative;z-index:1}.line-highlight{background:#f7ebc6;box-shadow:inset 5px 0 0 #f7d87c;left:0;line-height:inherit;margin-top:1em;padding-bottom:inherit;padding-left:0;padding-right:0;padding-top:inherit;pointer-events:none;position:absolute;right:0;white-space:pre;z-index:0}.footnotes,.post-list-container h1,.text,a,em,h2,h3,h4,h5,h6,li,p,ul{font-family:Vazir,monospace,Source Code Pro!important;line-height:1.6;margin:0;padding:0}.post-list-container ul{list-style-type:circle;padding:0}.post-list-container li a{color:#121212;-webkit-text-decoration-style:dotted;text-decoration-style:dotted}.post-list-container li{margin-top:16px}.category-container .badge{background-color:var(--primary-color-active);border-radius:5px;color:#fff;margin-left:5px;padding-left:4px;padding-right:4px}.post-list-container{direction:rtl;display:flex;flex-direction:row;flex-wrap:wrap;padding:3rem}.category-container{margin:2rem 1rem;width:calc(50% - 2rem)}.category-container .hr{background-color:var(--primary-color-active);border-radius:5px;height:5px;margin-bottom:1rem;margin-top:.1rem;width:40%}@media screen and (max-width:425px){.category-container{width:100%}.post-list-container{padding:1rem}}.social{display:flex;flex-direction:row;font-family:Source Code Pro!important;font-size:.9rem;justify-content:center;margin-top:20px;width:100%}.social a{color:grey!important;opacity:.6;transition:.2s}.social a:hover{opacity:1}.social p{margin-left:10px;margin-right:10px}</style><meta name="generator" content="Gatsby 4.1.3"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">چالش های پیاده سازی ratelimiter برای یک CDN - قسمت ۱</title><meta data-react-helmet="true" charSet="utf-8"/><meta data-react-helmet="true" property="og:title" content="چالش های پیاده سازی ratelimiter برای یک CDN - قسمت ۱"/><meta data-react-helmet="true" property="og:site_name" content="Sahand&#x27;s blog"/><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link as="script" rel="preload" href="/webpack-runtime-eb92277a3bb70a1028db.js"/><link as="script" rel="preload" href="/framework-02d188296aa8e09a771c.js"/><link as="script" rel="preload" href="/app-fc6519f31c6e62d185e1.js"/><link as="script" rel="preload" href="/b3cb720b120fadd5cd62c0f493389da7ab972379-9ace7c48e7e7a825d7a3.js"/><link as="script" rel="preload" href="/component---src-pages-ratelimit-p-1-mdx-e6a2f79308b17ab1af8e.js"/><link as="fetch" rel="preload" href="/page-data/ratelimit-p1/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="main-container-wrapper"><div class="main-container"><h1>چالش های پیاده سازی ratelimiter برای یک CDN - قسمت ۱</h1><div class="text"><a class="img-container" href="/images/ratelimit_funnel.png" target="_blank"><img src="/images/ratelimit_funnel.png" alt="Ratelimit funnel" dir="ltr" style="max-height:300px"/></a></div><br/><div class="text">اگر جایی توی اینترنت با پیام
<code dir="ltr">TOO_MANY_REQUESTS</code>
روبرو شدید، احتمال خیلی زیاد اون وبسایت
rate limit
داشته و تعداد درخواست های شما از حد مجاز تعریف شده برای اون وبسایت بیشتر شده و
rate limit
شدید. به طور کلی
rate limit
روشی برای کنترل جریان هست. توی یک سد اگر میخوایم میزان عبور آب رو کنترل کنیم، میایم جریان آب رو محدود میکنیم به طوری که فقط
x
مقدار آب در بازه زمانی
t
بتونه عبور کنه. توی یک وب سرور این موضوع این طور تعمیم داده میشه که تعداد درخواست های یک کاربر (معمولا کاربران با
IP Address
شون متمایز میشن) در یک بازه زمانی
t
(مثلا ۱۰ ثانیه‌ای) از x تا بیشتر نشه.</div><blockquote><div class="text">نکته: منظور از بازه زمانی توی هر الگوریتم ممکنه متفاوت باشه که جلوتر در موردش صحبت می‌کنیم.</div></blockquote><div class="text">معمولا مسیر های حساس یا مسیر هایی که پردازش سنگینی نیاز دارند رو
rate limit
می‌کنن. مثلا اگر مسیری مثل
<code dir="ltr">/auth/sendOTP</code>
که کارش ارسال رمز یکبار مصرف به یک شماره هست،
rate limit
نداشته باشه، یک نفر میتونه به تعداد دفعات زیادی این
endpoint
رو صدا بزنه و اعتبار پنل
SMS
تون رو خالی کنه. حالا این
rate limit
کردن چطوری انجام میشه؟</div><h2>موضوع یک: الگوریتم ها <sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></h2><div class="text">الگوریتم های مختلفی برای
rate limit
کردن وجود داره که هر کدومشون خوبی ها و بدی های خودشون رو دارن، اول همشون رو معرفی میکنیم
و میگیم چطوری کار میکنن و از آخر مقایسشون میکنیم، یکی رو انتخاب و ازش در ادامه مطلب استفاده می‌کنیم.</div><div class="text">نمونه زیر رو در نظر میگیریم تا باهاش بتونیم الگوریتم هارو بفهمیم:</div><br id="anchor-ratelimit-example"/><div class="text"><em dir="ltr">قانون rate limit ای که در بازه زمانی 10 ثانیه هر نفر که با IP Address اش متمایز میشه، اجازه داشته باشه ۵ درخواست HTTP ارسال کنه.</em></div><h3>الگوریتم Fixed Window</h3><div class="text">توی الگوریتم
fixed window
اول یک مبدا شروع زمان در نظر میگیریم که معمولا توی پیاده سازی ها، از
<a href="https://en.wikipedia.org/wiki/Unix_time" dir="ltr">Unix Time</a>
استفاده می‌شه. بعد از مشخص کردن مبدا، از مبدا شروع می‌کنیم و هر
t ثانیه
یک علامت می‌زاریم
(که اینجا t همون ۱۰ ثانیه قانونمون هست).
در آخر بازه های بین هر علامت رو بازه زمانی قانونمون در نظر میگیریم و هر نفر اجازه داره فقط
x
(که توی مثال برابر با ۵ است) درخواست در این بازه ها ارسال کنه.</div><div class="text"><a class="img-container" href="/images/ratelimit_fixed_window.png" target="_blank"><img src="/images/ratelimit_fixed_window.png" alt="Fixed Window timeline" dir="ltr"/></a></div><div class="text">همینطور که توی تصویر ۲ می‌بینید، توی بازه زمانی اول ۵ درخواست اول قبول شدن (فلش های سبز) و ۲ درخواست بعدی بلاک شدن و در بازه زمانی دوم مجدد فقط ۵ درخواست اول بازه  قابل قبول است.</div><div class="text">یک نمونه پیاده سازی این الگوریتم به زبان Rust:</div><blockquote><div class="text">▼ می‌تونید با زدن روی دکمه
<code dir="ltr">Rust Playground</code>
نسخه کامل و قابل اجراش رو ببینید.</div></blockquote><div style="position:relative"><div class="playground-button"><a target="_blank" href="https://play.rust-lang.org/?edition=2021&amp;code=use%20std%3A%3Acollections%3A%3AHashMap%3B%0Ause%20std%3A%3Atime%3A%3A%7BDuration%2C%20SystemTime%7D%3B%0A%0Astruct%20Rule%20%7B%0A%20%20%20%20time_duration%3A%20Duration%2C%0A%20%20%20%20rate%3A%20usize%2C%0A%7D%0A%0A%2F%2F%2F%20State%5Bint(now%20%2F%20time_duration)%5D%20-%3E%20counted%20requests%0Atype%20State%20%3D%20HashMap%3Cu128%2C%20usize%3E%3B%0A%0Afn%20is_rate_limited(%0A%20%20%20%20origin%3A%20SystemTime%2C%0A%20%20%20%20current_time%3A%20SystemTime%2C%0A%20%20%20%20rule%3A%20%26Rule%2C%0A%20%20%20%20state%3A%20%26mut%20State%2C%0A)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20current_time_ms%20%3D%20current_time.duration_since(origin).unwrap().as_millis()%3B%0A%20%20%20%20let%20time_duration_ms%20%3D%20rule.time_duration.as_millis()%3B%0A%20%20%20%20let%20state_idx%20%3D%20current_time_ms%20%2F%20time_duration_ms%3B%0A%0A%20%20%20%20let%20t_state%20%3D%20state.entry(state_idx).or_insert(0)%3B%0A%0A%20%20%20%20*t_state%20%2B%3D%201%3B%0A%0A%20%20%20%20*t_state%20%3E%20rule.rate%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20rule%20%3D%20%26Rule%20%7B%0A%20%20%20%20%20%20%20%20time_duration%3A%20Duration%3A%3Afrom_secs(5)%2C%0A%20%20%20%20%20%20%20%20rate%3A%205%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20origin%20%3D%20SystemTime%3A%3Anow()%3B%0A%20%20%20%20let%20mut%20current_time%20%3D%20SystemTime%3A%3Anow()%3B%0A%20%20%20%20let%20state%20%3D%20%26mut%20HashMap%3A%3Anew()%3B%0A%0A%20%20%20%20for%20_%20in%201..%3D5%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%7D%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(5)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%7D">Rust Playground</a></div><pre class="prism-code language-rust"><div class="token-line"><span class="token plain">struct Rule {</span></div><div class="token-line"><span class="token plain">    time_duration: Duration,</span></div><div class="token-line"><span class="token plain">    rate: usize,</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">/// State[int(now / time_duration)] -&gt; counted requests</span></div><div class="token-line"><span class="token plain">type State = HashMap&lt;u128, usize&gt;;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn is_rate_limited(</span></div><div class="token-line"><span class="token plain">    origin: SystemTime,</span></div><div class="token-line"><span class="token plain">    current_time: SystemTime,</span></div><div class="token-line"><span class="token plain">    rule: &amp;Rule,</span></div><div class="token-line"><span class="token plain">    state: &amp;mut State,</span></div><div class="token-line"><span class="token plain">) -&gt; bool {</span></div><div class="token-line"><span class="token plain">    let current_time_ms = current_time.duration_since(origin).unwrap().as_millis();</span></div><div class="token-line"><span class="token plain">    let time_duration_ms = rule.time_duration.as_millis();</span></div><div class="token-line"><span class="token plain">    let state_idx = current_time_ms / time_duration_ms;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    let t_state = state.entry(state_idx).or_insert(0);</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    *t_state += 1;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    *t_state &gt; rule.rate</span></div><div class="token-line"><span class="token plain">}</span></div></pre></div><h3>الگوریتم Leaky Bucket</h3><div class="text">در این الگوریتم درخواست ها قبل از پردازش شدن وارد یک صف می‌شن و منتظر می‌مونن.
این صف یک ظرفیت داره
(rate)
که اگر درخواست جدید اومد و صف پر بود،
درخواست بلاک می‌شه.
از این صف هر <code dir="ltr">t / rate</code> ثانیه <sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>
یک المان کم میشه تا وقتی که صف خالی بشه.</div><div class="text"><a class="img-container" href="/images/ratelimit_leaky_bucket.png" target="_blank"><img src="/images/ratelimit_leaky_bucket.png" alt="leaky bucket" dir="ltr" style="max-width:350px"/></a></div><div class="text">این الگوریتم جدا از اینکه می‌تونه برای
rate limit
کردن استفاده بشه، ‌می‌تونه به عنوان یک کنترل کننده جریان هم استفاده بشه
که درخواست ها با یک نرخ ثابت و کنترل شده انجام بشن.</div><div class="text">نمونه پیاده سازی این الگوریتم به صورت async در زبان Rust:</div><div style="position:relative"><div class="playground-button"><a target="_blank" href="https://play.rust-lang.org/?edition=2021&amp;code=use%20std%3A%3Atime%3A%3A%7BDuration%2C%20Instant%7D%3B%0Ause%20tokio%3A%3A%7B%0A%20%20%20%20sync%3A%3A%7Bmpsc%2C%20oneshot%7D%2C%0A%20%20%20%20time%3A%3Asleep%2C%0A%7D%3B%0A%0Astruct%20Waiter(oneshot%3A%3AReceiver%3C()%3E)%3B%0Aimpl%20Waiter%20%7B%0A%20%20%20%20async%20fn%20wait_in_queue(self)%20%7B%0A%20%20%20%20%20%20%20%20self.0.await.unwrap()%3B%0A%20%20%20%20%7D%0A%7D%0Atype%20RequestResumer%20%3D%20oneshot%3A%3ASender%3C()%3E%3B%0A%0A%23%5Bderive(Clone)%5D%0Astruct%20Rule%20%7B%0A%20%20%20%20time_duration%3A%20Duration%2C%0A%20%20%20%20rate%3A%20u32%2C%0A%7D%0A%0Atype%20Request%20%3D%20(RequestResumer%2C%20Waiter)%3B%0Atype%20Bucket%20%3D%20mpsc%3A%3ASender%3CRequestResumer%3E%3B%0A%0Aasync%20fn%20is_rate_limited(req%3A%20Request%2C%20bucket_tx%3A%20Bucket)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20(req%2C%20waiter)%20%3D%20req%3B%0A%20%20%20%20match%20bucket_tx.try_send(req)%20%7B%0A%20%20%20%20%20%20%20%20Ok(_)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20waiter.wait_in_queue().await%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20false%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20queue%20is%20full%0A%20%20%20%20%20%20%20%20Err(_)%20%3D%3E%20true%2C%0A%20%20%20%20%7D%0A%7D%0A%0Aasync%20fn%20leak(rule%3A%20Rule%2C%20mut%20bucket_rx%3A%20mpsc%3A%3AReceiver%3CRequestResumer%3E)%20%7B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20if%20let%20Some(resumer)%20%3D%20bucket_rx.try_recv().ok()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20resumer.send(()).unwrap()%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20sleep(rule.time_duration%20%2F%20rule.rate).await%3B%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Btokio%3A%3Amain%5D%0Aasync%20fn%20main()%20%7B%0A%20%20%20%20let%20rule%20%3D%20Rule%20%7B%0A%20%20%20%20%20%20%20%20rate%3A%205%2C%0A%20%20%20%20%20%20%20%20time_duration%3A%20Duration%3A%3Afrom_secs(5)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20(bucket_tx%2C%20bucket_rx)%20%3D%20mpsc%3A%3Achannel(rule.rate%20as%20_)%3B%0A%20%20%20%20let%20_%20%3D%20tokio%3A%3Aspawn(leak(rule%2C%20bucket_rx))%3B%0A%20%20%20%20let%20mut%20tasks%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20for%20i%20in%201..%3D7%20%7B%0A%20%20%20%20%20%20%20%20let%20bucket%20%3D%20bucket_tx.clone()%3B%0A%20%20%20%20%20%20%20%20let%20task%20%3D%20tokio%3A%3Aspawn(async%20move%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22%5Bstart%5D%20request%20%7B%7D%22%2C%20i)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20chan%20%3D%20oneshot%3A%3Achannel()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20req%20%3D%20(chan.0%2C%20Waiter(chan.1))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20start%20%3D%20Instant%3A%3Anow()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20result%20%3D%20is_rate_limited(req%2C%20bucket).await%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22%5Bdone%5D%20request%20%7B%7D%20after%20%7B%3A%3F%7D%20%3D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20i%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20start.elapsed()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20result%0A%20%20%20%20%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20%7D)%3B%0A%20%20%20%20%20%20%20%20tasks.push(task)%3B%0A%20%20%20%20%7D%0A%20%20%20%20for%20task%20in%20tasks%20%7B%0A%20%20%20%20%20%20%20%20task.await.unwrap()%3B%0A%20%20%20%20%7D%0A%7D">Rust Playground</a></div><pre class="prism-code language-rust"><div class="token-line"><span class="token plain">struct Rule {</span></div><div class="token-line"><span class="token plain">    time_duration: Duration,</span></div><div class="token-line"><span class="token plain">    rate: u32,</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">type Request = (RequestResumer, Waiter);</span></div><div class="token-line"><span class="token plain">type Bucket = mpsc::Sender&lt;RequestResumer&gt;;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">async fn is_rate_limited(req: Request, bucket_tx: Bucket) -&gt; bool {</span></div><div class="token-line"><span class="token plain">    let (req, waiter) = req;</span></div><div class="token-line"><span class="token plain">    match bucket_tx.try_send(req) {</span></div><div class="token-line"><span class="token plain">        Ok(_) =&gt; {</span></div><div class="token-line"><span class="token plain">            waiter.wait_in_queue().await;</span></div><div class="token-line"><span class="token plain">            false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // queue is full</span></div><div class="token-line"><span class="token plain">        Err(_) =&gt; true,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">async fn leak(rule: Rule, mut bucket_rx: mpsc::Receiver&lt;RequestResumer&gt;) {</span></div><div class="token-line"><span class="token plain">    loop {</span></div><div class="token-line"><span class="token plain">        if let Some(resumer) = bucket_rx.try_recv().ok() {</span></div><div class="token-line"><span class="token plain">            resumer.send(()).unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        sleep(rule.time_duration / rule.rate).await;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">}</span></div></pre></div><h3>الگوریتم Sliding Window Log ـ <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup></h3><div class="text">این الگوریتم با ذخیره کردن timestamp هر درخواست کار می‌کنه.
وقتی یک درخواست جدید دریافت می‌کنیم:</div><ul><li>ابتدا تمام timestamp های قدیمی شده رو پاک می‌کنیم.</li><li>درخواست جدید رو رکورد می‌کنیم</li><li>در نهایت با چک کردن اندازه رکورد هامون، تصمیم میگیریم که request رو بلاک کنیم یا نه.</li></ul><div class="text">بیایم اینو با مثالی که
<a href="#anchor-ratelimit-example" dir="ltr">بالا</a>
زدیم، باز کنیم:</div><div class="text"><a class="img-container" href="/images/ratelimit_sliding_window_log_1.png" target="_blank"><img src="/images/ratelimit_sliding_window_log_1.png" alt="sliding window log diagram 1" dir="ltr"/></a></div><div class="text">در ابتدا ۵ درخواست داریم که هر کدوم با فاصله های زمانی یک ثانیه‌ای به سمت ما ارسال میشن.
چون از قبل رکوردی نداریم و زمان ها در بازه
threshold
هستند(جلوتر میفهمیم این چیه)
هیچکدوم پاک نمیشن و همشون ثبت میشن. لاگمون الان اندازش ۵ هست و
چون بزرگتر از rate امون نیست،
لازم نیست آخرین درخواست رو بلاک کنیم. میریم جلوتر:</div><div class="text"><a class="img-container" href="/images/ratelimit_sliding_window_log_2.png" target="_blank"><img src="/images/ratelimit_sliding_window_log_2.png" alt="sliding window log diagram 2" dir="ltr"/></a></div><div class="text">یک ثانیه بعد یک درخواست جدید میاد، همه رکورد های قبلی توی بازه زمانیمون قرار دارن
(نقطه چین)
در نتیجه هیچ رکوردی حذف نمیشه. درخواست فعلی رو رکورد می‌کنیم. چون اندازه
لاگمون بیشتر از ۵ شد، باید درخواست رو بلاک کنیم.</div><blockquote><div class="text">بازه زمانی توی sliding window log میشه بازه درخواست فعلی تا t ثانیه<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> قبل.</div></blockquote><div class="text">بریم جلوتر:</div><div class="text"><a class="img-container" href="/images/ratelimit_sliding_window_log_3.png" target="_blank"><img src="/images/ratelimit_sliding_window_log_3.png" alt="sliding window log diagram 3" dir="ltr"/></a></div><div class="text">۲ ثانیه بعد، یک درخواست جدید میاد.
چون رکورد های ۱ و ۲ خارج از بازه زمان هستن، اونارو از لاگمون پاک می‌کنیم،
بعد درخواست فعلی رو رکورد می‌کنیم. چون اندازه لاگمون بیشتر از ۵ نیست،
لازم نیست درخواست رو بلاک کنیم. این الگوریتم به همین ترتیب برای درخواست بعدی
عمل می‌کنه.</div><br/><div class="text">یکی از خوبی های این الگوریتم، تعریف متفاوت اون از بازه نسبت به
الگوریتم fixed window هست.
بازه ها توی
fixed window
ثابت اما اینجا پویاست. در نتیجه این الگوریتم گارانتی می‌کنه که درخواست هایی فقط
قبول می‌شن که تعداد درخواست ها
از t ثانیه قبلشون تا به الان
از حد قانون یا rate
بیشتر نباشه.</div><div class="text">اما در fixed window این گارانتی وجود نداره در نتیجه اگه قانونی مثل
<code dir="ltr">rate=1000, t=24hr</code> داشته باشیم و فرض کنیم
origin همان ابتدای روز است،
اگه کاربر از ۹ تا ۱۰ صبح 1000 درخواست خودش رو مصرف کنه، دیگه اجازه نداره تا روز بعدی درخواست جدیدی بفرسته.
اما توی sliding window اینطور نیست و بعد از ظهر می‌تونه
مجدد درخواست ارسال کنه. نه
1000 تا
،‌ کمتر ولی دسترسیش کامل از سایت قطع نمیشه.<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup>
بجاش صبح روز بعد کمتر از 1000 تا درخواست می‌تونه ارسال کنه.</div><br/><div class="text">این الگوریتم بدی هم داره، مموری زیادی نسبت به الگوریتم های دیگه مصرف می‌کنه و تحت کنترلمون نیست.
توی fixed window
ما می‌دونیم که هر کاربر یک اندازه ثابت مموری نیاز داره و بیشتر نمیشه
(مثلا ۱۲۸ بایت ثابت)
اما توی sliding window log
چون ما باید لیستی از لاگ ها رو برای هر کاربر ذخیره کنیم، دقیقا نمی‌دونیم که هر کاربر چقدر مموری نیاز داره.
مثلا یک کاربر میتونه نسبت به درخواست هایی که میده ۱۰ مگابایت مموری مصرف کنه و
یک کاربر دیگه ۱۰۰ کیلوبایت.</div><div class="text">مشکل دیگه‌ای هم که داره اگه از یک کاربر ۵ مگابایت رکورد داشته باشیم و این کاربر هیچوقت دیگه
به سایتمون سر نزنه، هیچ وقت رکورد های قدیمی رو پاک نمی‌کنیم و این ۵ مگ رو الکی نگه داشتیم و از منابع به خوبی استفاده نکردیم.
در نتیجه باید یک فرایند پس‌زمینه‌ای داشته باشیم که هرچند وقت یکبار همه رکورد ها برای همه کاربر هارو
بررسی کنه و رکورد های قدیمی رو پاک کنه. اگه این کار رو هم انجام بدیم مشکلات همزمانی
خودشون رو نشون میدن که اگه اونارو هم با لاک کردن حل کنیم، روی پرفرمنس تاثیر زیادی میزارن
که برای سیستمی که بار سنگینی رو پردازش میکنه
(مثل CDN)
اصلا ایده‌آل نیست. جلوتر توی این نوشته بیشتر در این مورد صحبت می‌شه.</div><div class="text">نمونه پیاده سازی این الگوریتم در زبان Rust:</div><div style="position:relative"><div class="playground-button"><a target="_blank" href="https://play.rust-lang.org/?edition=2021&amp;code=use%20std%3A%3Atime%3A%3A%7BDuration%2C%20SystemTime%2C%20UNIX_EPOCH%7D%3B%0A%0Astruct%20Rule%20%7B%0A%20%20%20%20time_duration%3A%20Duration%2C%0A%20%20%20%20rate%3A%20usize%2C%0A%7D%0A%0Atype%20Log%20%3D%20Vec%3Cu128%3E%3B%0A%0Afn%20is_rate_limited(current_time%3A%20SystemTime%2C%20rule%3A%20%26Rule%2C%20log%3A%20%26mut%20Log)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20current_timestamp%20%3D%20current_time.duration_since(UNIX_EPOCH).unwrap().as_millis()%3B%0A%20%20%20%20let%20time_duration_ms%20%3D%20rule.time_duration.as_millis()%3B%0A%20%20%20%20%2F%2F%20cleanup%0A%20%20%20%20let%20mut%20logs_to_pop%20%3D%200%3B%0A%20%20%20%20for%20timestamp%20in%20log.iter()%20%7B%0A%20%20%20%20%20%20%20%20if%20*timestamp%20%3C%20current_timestamp%20-%20time_duration_ms%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20logs_to_pop%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20log.drain(0..logs_to_pop)%3B%0A%20%20%20%20if%20log.len()%20%3E%3D%20rule.rate%20%7B%0A%20%20%20%20%20%20%20%20true%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20append%0A%20%20%20%20%20%20%20%20log.push(current_timestamp)%3B%0A%20%20%20%20%20%20%20%20false%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20rule%20%3D%20%26Rule%20%7B%0A%20%20%20%20%20%20%20%20time_duration%3A%20Duration%3A%3Afrom_secs(5)%2C%0A%20%20%20%20%20%20%20%20rate%3A%205%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20mut%20current_time%20%3D%20SystemTime%3A%3Anow()%3B%0A%20%20%20%20let%20state%20%3D%20%26mut%20Vec%3A%3Anew()%3B%0A%0A%20%20%20%20for%20_%20in%201..%3D5%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(is_rate_limited(current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(1)%3B%0A%20%20%20%20%7D%0A%20%20%20%20assert_eq!(is_rate_limited(current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(2)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%7D">Rust Playground</a></div><pre class="prism-code language-rust"><div class="token-line"><span class="token plain">struct Rule {</span></div><div class="token-line"><span class="token plain">    time_duration: Duration,</span></div><div class="token-line"><span class="token plain">    rate: usize,</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">type Log = Vec&lt;u128&gt;;</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn is_rate_limited(current_time: SystemTime, rule: &amp;Rule, log: &amp;mut Log) -&gt; bool {</span></div><div class="token-line"><span class="token plain">    let current_timestamp = current_time.duration_since(UNIX_EPOCH).unwrap().as_millis();</span></div><div class="token-line"><span class="token plain">    let time_duration_ms = rule.time_duration.as_millis();</span></div><div class="token-line"><span class="token plain">    // cleanup</span></div><div class="token-line"><span class="token plain">    let mut logs_to_pop = 0;</span></div><div class="token-line"><span class="token plain">    for timestamp in log.iter() {</span></div><div class="token-line"><span class="token plain">        if *timestamp &lt; current_timestamp - time_duration_ms {</span></div><div class="token-line"><span class="token plain">            logs_to_pop += 1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    log.drain(0..logs_to_pop);</span></div><div class="token-line"><span class="token plain">    if log.len() &gt;= rule.rate {</span></div><div class="token-line"><span class="token plain">        true</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        // append</span></div><div class="token-line"><span class="token plain">        log.push(current_timestamp);</span></div><div class="token-line"><span class="token plain">        false</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">}</span></div></pre></div><h3>الگوریتم Sliding Window ـ <sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup></h3><div class="text">این الگوریتم میاد مشکل الگوریتم
fixed window
که توی بازه های زمانی ثابت، شمارنده رو صفر می‌کنه رو حل می‌کنه،
به این صورت که دو شمارنده داره، یکی برای
پنجره ثابت فعلی
و یکی برای قبلی. به شمارنده قبلی یک وزن میده و با شمارنده فعلی جمعش میکنه
تا یک تقریب نسبتا خوبی برای rate بدست بیاره
و در نهایت اونو با
rate
قانونمون چک می‌کنه. بیایم برای اینکه بهتر بفهمیم، مثل الگوریتم قبل اینم
با مثال
<a href="#anchor-ratelimit-example" dir="ltr">بالا</a>
بازش کنیم:</div><div class="text"><a class="img-container" href="/images/ratelimit_sliding_window_1.png" target="_blank"><img src="/images/ratelimit_sliding_window_1.png" alt="sliding window 1" dir="ltr"/></a></div><div class="text">فرض می‌کنیم اول ۵ تا درخواست اومدن و مثل تصویر بالا توی ثانیه 8ام، آخرینشون رو شمردیم.
توی ثانیه 12ام یک درخواست جدید میاد:</div><div class="text"><a class="img-container" href="/images/ratelimit_sliding_window_2.png" target="_blank"><img src="/images/ratelimit_sliding_window_2.png" alt="sliding window 2" dir="ltr"/></a></div><div class="text">یک بازه به اندازه t که اینجا
10 ثانیه هست در نظر می‌گیریم و آخرش رو زمان فعلی درخواستمون می‌زاریم.
اول این بازه میوفته توی <code dir="ltr">current_time - t</code> که توی این مثال میشه
ثانیه 2م.
حالا باید ببینیم که چند درصد این بازه توی
پنجره ثابت
قبلی افتاده که اینجا میشه
80 درصد در نتیجه وزنمون میشه 0.8. شرط چک کردنمون میشه:</div><div style="position:relative"><pre class="prism-code language-text"><div class="token-line"><span class="token plain">rate = last_rate * weight + current_rate</span></div><div class="token-line"><span class="token plain">rate = 5 * 0.8 + 0 = 4</span></div></pre></div><div class="text">چون عددی که بدست اوردیم کمتر از
rate
قانونمونه، درخواست بلاک نمیشه و به شمارنده پنجره ثابت فعلی یکی اضافه می‌کنیم.
وقتی هم میریم به پنجره بعدی (مثلا بریم بعد از ثانیه 20ام)
میایم مقدار <code dir="ltr">current_rate</code> رو میریزیم توی <code dir="ltr">last_rate</code> و
<code dir="ltr">current_rate</code> رو صفر می‌کنیم.</div><div class="text">یک نمونه پیاده سازی کامل این الگوریتم:</div><div style="position:relative"><div class="playground-button"><a target="_blank" href="https://play.rust-lang.org/?edition=2021&amp;code=use%20std%3A%3Atime%3A%3A%7BDuration%2C%20Instant%7D%3B%0A%0A%23%5Bderive(Clone)%5D%0Astruct%20Rule%20%7B%0A%20%20%20%20time_duration%3A%20Duration%2C%0A%20%20%20%20rate%3A%20usize%2C%0A%7D%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20State%20%7B%0A%20%20%20%20%2F%2F%2F%20last%20time%20we%20counted%20a%20request%0A%20%20%20%20pub%20last_count_time%3A%20Instant%2C%0A%20%20%20%20%2F%2F%2F%20last%20block%20request%20count%0A%20%20%20%20pub%20last_window_count%3A%20usize%2C%0A%20%20%20%20%2F%2F%2F%20current%20window%20request%20count%0A%20%20%20%20pub%20current_window_count%3A%20usize%2C%0A%7D%0A%0Afn%20is_rate_limited(origin%3A%20Instant%2C%20current_time%3A%20Instant%2C%20rule%3A%20%26Rule%2C%20state%3A%20%26mut%20State)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20duration_since_last_req%20%3D%20current_time.duration_since(state.last_count_time)%3B%0A%20%20%20%20if%20duration_since_last_req%20%3E%3D%20rule.time_duration%20*%202%20%7B%0A%20%20%20%20%20%20%20%20state.last_window_count%20%3D%200%3B%0A%20%20%20%20%20%20%20%20state.current_window_count%20%3D%200%3B%0A%20%20%20%20%7D%20else%20if%20duration_since_last_req%20%3E%20rule.time_duration%20%7B%0A%20%20%20%20%20%20%20%20state.last_window_count%20%3D%20state.current_window_count%3B%0A%20%20%20%20%20%20%20%20state.current_window_count%20%3D%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20let%20t_ms%20%3D%20rule.time_duration.as_millis()%3B%0A%20%20%20%20let%20current_window_start%20%3D%20%7B%0A%20%20%20%20%20%20%20%20let%20normal%20%3D%20current_time.duration_since(origin).as_millis()%20%2F%20t_ms%3B%0A%20%20%20%20%20%20%20%20origin%20%2B%20Duration%3A%3Afrom_millis((normal%20*%20t_ms)%20as%20_)%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20w%20%3D%20%7B%0A%20%20%20%20%20%20%20%20let%20d%20%3D%20current_time%20-%20current_window_start%3B%0A%20%20%20%20%20%20%20%20let%20dp%20%3D%20if%20d%20%3E%20rule.time_duration%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Duration%3A%3AZERO%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20rule.time_duration%20-%20d%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20(dp.as_millis()%20as%20f64)%20%2F%20t_ms%20as%20f64%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20count%20%3D%20((w%20*%20state.last_window_count%20as%20f64)%20as%20usize)%20%2B%20state.current_window_count%3B%0A%20%20%20%20if%20count%20%3E%3D%20rule.rate%20%7B%0A%20%20%20%20%20%20%20%20return%20true%3B%0A%20%20%20%20%7D%0A%20%20%20%20state.last_count_time%20%3D%20current_time%3B%0A%20%20%20%20state.current_window_count%20%2B%3D%201%3B%0A%20%20%20%20false%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20rule%20%3D%20%26Rule%20%7B%0A%20%20%20%20%20%20%20%20time_duration%3A%20Duration%3A%3Afrom_secs(10)%2C%0A%20%20%20%20%20%20%20%20rate%3A%20100%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20origin%20%3D%20Instant%3A%3Anow()%3B%0A%20%20%20%20let%20mut%20current_time%20%3D%20origin%3B%0A%20%20%20%20let%20state%20%3D%20%26mut%20State%20%7B%0A%20%20%20%20%20%20%20%20current_window_count%3A%200%2C%0A%20%20%20%20%20%20%20%20last_window_count%3A%200%2C%0A%20%20%20%20%20%20%20%20last_count_time%3A%20origin%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20for%20_%20in%201..%3D90%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%7D%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(12)%3B%0A%20%20%20%20for%20_%20in%201..%3D28%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%7D%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(20)%3B%0A%20%20%20%20for%20_%20in%201..%3D100%20%7B%0A%20%20%20%20%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%7D%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_secs(10)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20true)%3B%0A%20%20%20%20current_time%20%2B%3D%20Duration%3A%3Afrom_millis(1)%3B%0A%20%20%20%20assert_eq!(is_rate_limited(origin%2C%20current_time%2C%20rule%2C%20state)%2C%20false)%3B%0A%20%20%20%20%0A%7D">Rust Playground</a></div><pre class="prism-code language-rust"><div class="token-line"><span class="token plain">struct Rule {</span></div><div class="token-line"><span class="token plain">    time_duration: Duration,</span></div><div class="token-line"><span class="token plain">    rate: usize,</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">struct State {</span></div><div class="token-line"><span class="token plain">    /// last time we counted a request</span></div><div class="token-line"><span class="token plain">    pub last_count_time: Instant,</span></div><div class="token-line"><span class="token plain">    /// last block request count</span></div><div class="token-line"><span class="token plain">    pub last_window_count: usize,</span></div><div class="token-line"><span class="token plain">    /// current window request count</span></div><div class="token-line"><span class="token plain">    pub current_window_count: usize,</span></div><div class="token-line"><span class="token plain">}</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">fn is_rate_limited(origin: Instant, current_time: Instant, rule: &amp;Rule, state: &amp;mut State) -&gt; bool {</span></div><div class="token-line"><span class="token plain">    let duration_since_last_req = current_time.duration_since(state.last_count_time);</span></div><div class="token-line"><span class="token plain">    if duration_since_last_req &gt;= rule.time_duration * 2 {</span></div><div class="token-line"><span class="token plain">        state.last_window_count = 0;</span></div><div class="token-line"><span class="token plain">        state.current_window_count = 0;</span></div><div class="token-line"><span class="token plain">    } else if duration_since_last_req &gt; rule.time_duration {</span></div><div class="token-line"><span class="token plain">        state.last_window_count = state.current_window_count;</span></div><div class="token-line"><span class="token plain">        state.current_window_count = 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    let t_ms = rule.time_duration.as_millis();</span></div><div class="token-line"><span class="token plain">    let current_window_start = {</span></div><div class="token-line"><span class="token plain">        let normal = current_time.duration_since(origin).as_millis() / t_ms;</span></div><div class="token-line"><span class="token plain">        origin + Duration::from_millis((normal * t_ms) as _)</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    let w = {</span></div><div class="token-line"><span class="token plain">        let d = current_time - current_window_start;</span></div><div class="token-line"><span class="token plain">        let dp = if d &gt; rule.time_duration {</span></div><div class="token-line"><span class="token plain">            Duration::ZERO</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            rule.time_duration - d</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">        (dp.as_millis() as f64) / t_ms as f64</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">    let count = ((w * state.last_window_count as f64) as usize) + state.current_window_count;</span></div><div class="token-line"><span class="token plain">    if count &gt;= rule.rate {</span></div><div class="token-line"><span class="token plain">        return true;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    state.last_count_time = current_time;</span></div><div class="token-line"><span class="token plain">    state.current_window_count += 1;</span></div><div class="token-line"><span class="token plain">    false</span></div><div class="token-line"><span class="token plain">}</span></div></pre></div><blockquote><div class="text">توی پیاده سازی بالا ما زمان آخرین درخواست هم ذخیره می‌کنیم این به این دلیل هست که چک کنیم
که اگه درخواست جدید با آخرین درخواست ۲ تا بازه زمانی فاصله داشته باشن، بیایم و
<code dir="ltr">current_rate</code> و <code dir="ltr">last_rate</code> رو صفر کنیم.</div></blockquote><h3>مقایسه و انتخاب یک الگوریتم</h3><div class="text">حالا که با 4 تا از الگوریتم های
rate limit
آشنا شدیم، بیایم اینارو با هم مقایسه کنیم و در نهایت یکی از اون‌هارو
برای استفاده توی
CDN
مون انتخاب کنیم.</div><h4>مموری</h4><ul><li><code>fixed window</code> ‌برای هر کاربر مموری ثابتی نیاز داره و رشد نمی‌کنه.</li><li><code>leaky bucket</code> مموری ثابتی نداره اما حداکثر مورد نیاز نسبت به قانون مشخص میشه.</li><li><code>sliding window log</code> برای هر کاربر مموری رشد می‌کنه و حداکثری وجود نداره.</li><li><code>sliding window</code> برای هر کاربر مموری ثابتی نیاز داره و رشد نمی‌کنه.</li></ul><h4>درستی</h4><ul><li><code>fixed window</code> این مشکل رو داره که شمارنده ها یک‌دفعه در تایم های مشخص ریست می‌شن.</li><li><code>leaky bucket</code> رفتاری داره که کاربران معمولا انتظار اون رو ندارن.
معمولا وب‌سایت ها می‌خوان که توی یک بازه زمانی یک تعداد فقط درخواست رد بشه نه اینکه
در یک بازه زمانی با یک نرخ ثابت درخواست داشته باشیم. این باعث میشه استفاده کننده به اشتباه بیوفته.</li><li><code>sliding window log</code> درست‌ترین خروجی رو داره.</li><li><code>sliding window</code> خروجی تقریبی اما خیلی خوبی داره.</li></ul><div class="text">از لحاظ مموری
<code dir="ltr">fixed window</code> و <code dir="ltr">sliding window</code>
بهترین هستند و درست‌ترین بین این دوتا،
<code dir="ltr">sliding window</code> هست.
پس بهتره در ادامه کار، با این الگوریتم جلو بریم.</div><br/><br/><div class="text">در
<a href="/ratelimit-p2" dir="ltr">قسمت بعد</a>
، به این می‌پردازیم که این الگوریتم در محیط همزمان توی یک سرور چطور عمل می‌کنه.</div><hr/><h3>پانویس</h3><ol class="footnotes"><li id="fn-1">در عمل ممکنه بعضی از الگوریتم ها با یکم تغییر پیاده سازی شده باشن.<a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2">یا هر واحد زمانی دیگر<a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3">با نام Sliding Log هم شناخته می‌شود<a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4">یا هر واحد زمان دیگه<a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5">این می‌تونه هم خوب باشه هم بد ولی اکثر استفاده کنندگان ratelimit، این مدل رو بیشتر ترجیح میدن.<a href="#fnref-5" class="footnote-backref">↩</a></li><li id="fn-6">پیاده سازی های مختلفی از این الگوریتم برای RateLimit وجود داره ولی ما تارگتمون پیاده سازی <a href="https://blog.cloudflare.com/counting-things-a-lot-of-different-things/">کلادفلیر</a> هست<a href="#fnref-6" class="footnote-backref">↩</a></li></ol><h3>منابع</h3><div dir="ltr" class="resources"><div class="text">[<!-- -->1<!-- -->]<!-- -->: <a href="https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm" dir="ltr">https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm</a></div><div class="text">[<!-- -->2<!-- -->]<!-- -->: <a href="https://www.codementor.io/@arpitbhayani/system-design-sliding-window-based-rate-limiter-157x7sburi" dir="ltr">https://www.codementor.io/@arpitbhayani/system-design-sliding-window-based-rate-limiter-157x7sburi</a></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/ratelimit-p1/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-d69664561c90ab43065f.js"],"app":["/app-fc6519f31c6e62d185e1.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-f320ba337d28ea2b66b6.js"],"component---src-pages-context-magic-mdx":["/component---src-pages-context-magic-mdx-7d815f0fda3b761b850a.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-f1114d5558dbd6ea36c1.js"],"component---src-pages-ratelimit-p-1-mdx":["/component---src-pages-ratelimit-p-1-mdx-e6a2f79308b17ab1af8e.js"],"component---src-pages-ratelimit-p-2-mdx":["/component---src-pages-ratelimit-p-2-mdx-d396b307766e78b1a114.js"],"component---src-pages-usb-switcher-mdx":["/component---src-pages-usb-switcher-mdx-3ae427c094674b038772.js"],"component---src-pages-v-8-ignition-mdx":["/component---src-pages-v-8-ignition-mdx-81a18377b88f88e9a629.js"],"component---src-pages-v-8-jit-mdx":["/component---src-pages-v-8-jit-mdx-524980411d4111a105cd.js"],"component---src-pages-v-8-mdx":["/component---src-pages-v-8-mdx-a3e700e62668fa47202f.js"],"component---src-pages-v-8-parser-mdx":["/component---src-pages-v-8-parser-mdx-2d45c7f76e544a018b51.js"]};/*]]>*/</script><script src="/polyfill-d69664561c90ab43065f.js" nomodule=""></script><script src="/component---src-pages-ratelimit-p-1-mdx-e6a2f79308b17ab1af8e.js" async=""></script><script src="/b3cb720b120fadd5cd62c0f493389da7ab972379-9ace7c48e7e7a825d7a3.js" async=""></script><script src="/app-fc6519f31c6e62d185e1.js" async=""></script><script src="/framework-02d188296aa8e09a771c.js" async=""></script><script src="/webpack-runtime-eb92277a3bb70a1028db.js" async=""></script></body></html>