# V8 چیه و چطور کار می‌کنه؟

![v8-engine#@{"maxHeight":300}](v8_intro_1.png)

<br />
<br />
<br />

V8 یک موتور برای اجرای جاوااسکریپت و وب‌اسمبلی هست که
در نرم‌افزار های مختلفی مثل
Google chrome
و
nodejs
استفاده می‌شه. این موتور پرفرمنس خیلی بالایی داره و دلیلش خلاقیت و تکنولوژی های جالبی هست که توش استفاده کردن.
هدف این پست اینه که بیاد این پروژه رو معرفی کنه و تا حد خوبی به جزئیات اینکه چطور کار می‌کنه٬ بپردازه.

بیایم اسکریپت زیر رو در نظر بگیریم و ببینیم
وقتی به v8 میدیمش٬ باهاش چی‌کار می‌کنه.

```js
function salam() {
  const b = "hello";
  console.log(b);
}

function askAge() {
  let age = prompt("how old are you?");
  age = parseInt(age);
  return age;
}

function validate(age) {
  if (age < 18) {
    console.log(`you are under age, come back ${18 - age} years later`);
  } else {
    console.log("hello");
  }
}

salam();
var age = askAge();
validate(age);
```

اسکریپت بالا کارش اینه که به کاربر سلام کنه، سنش رو بپرسه و اگر سنش از ۱۸ سال کمتر بود٬ پیام خطا بده.

## مرحله اول - تولید Abstract Syntax Tree

برای اینکه بشه یک کد جاوااسکریپت رو اجرا کرد٬ باید اول کد اونو به یک فرمت مخصوصی تبدیل کنیم که موتور
v8 راحت‌تر بتونه باهاش کار کنه.
این فرمت Abstract Syntax Tree یا AST هست که نشون دهنده ساختار اصلی کده و همه داده های اضافه مثل کامنت
و اسپیس از اون حذف شده.
AST کد خودمون همچین چیزی هست:

![TODO: create ast for the example code](https://raw.githubusercontent.com/mdevils/cst/master/docs/cst-example.png)

برای این‌که V8 این AST رو تولید کنه٬
مراحل زیر رو انجام میده:

![TODO: ](https://v8.dev/_img/scanner/overview.svg)

بریم ببینیم هر مرحله‌اش داره چیکار می‌کنه.

> توی V8 چون تا وقتی AST
> نداشته باشیم نمی‌تونیم هیچکاری انجام بدیم٬
> V8 میاد AST رو به صورت streaming تولید می‌کنه.
> خیلی ساده یعنی مثلا توی کد بالا٬ وقتی تمام کاراکتر های مورد نیازش برای تابع اول رو دریافت کرد
> یک Node توی AST ایجاد می‌کنه و اونو بر میگردونه ولی می‌گه هنوز کارش تموم نشده.
> اینطوری V8 میتونه مثلا تابع اول رو اجرا کنه با اینکه هنوز بقیه کد رو
> parse نکرده.

### Scanner ـ [^1]

کامپایلر هر زبان برنامه‌نویسی برای اینکه بتونه خروجی تولید کنه٬ باید اول بتونه کدهای شمارو بفهمه. اولین قدم فهمیدن٬
بررسی رشته ورودی‌ای هست که بهش دادین. اگه کد زیر رو داشته باشیم:

```javascript
if (allow == true) {
  console.log("welcome");
}
```

کامپایلر باید توالی کاراکتر های ورودی رو بخونه و اونو تبدیل به توکن کنه که کار فهمیدن راحت‌تر بشه:

![scanner example](v8_scanner_1.png)

فرض کنیم تصویر بالا٬ ساده شده یک scanner برای جاوااسکریپت هست.
کد خودمون رو دادیم بهش و اون توی خروجی بهمون یک توالی از token ها داده.
کار کردن با این توکن ها برای فهم کد به مراتب راحت‌تر از مستقیم کار کردن روی کاراکتر هاست.
مثلا بعدا اگر بخوایم بفهمیم که آیا کاربر اینجا یک شرط نوشته باید دنبال یک الگو از توکن های پشت سر هم باشیم مثلا:

`[..., IF, PARAN_OPEN, IDENT, PARAN_CLOSE, ...]`
یا
`[..., IF, PARAN_OPEN, KEYWORD, PARAN_CLOSE, ...]`

که پیدا کردن این الگو به کمک لیست توکن ها خیلی ساده‌تر هست. این قسمت یک نکته مهمی که داره اینه که ممکنه همچین ورودی داشته باشیم:

```javascript
if if if true
```

که توی جاوااسکریپت معنی نمیده ولی
scanner
باز هم توالی توکن
`[IF, IF, IF, TRUE]`
رو تولید می‌کنه و تایید اعتبار ترکیب درست توکن ها کنار هم توی مرحله بعد یعنی پارسر انجام می‌شه.

> نکته: داخل scanner بالا کاراکتر های اضافه مثل فاصله و خط جدید هم حذف شدن ولی لزوما هر کامپایلری این کار رو توی این مرحله انجام نمیده.

به این تیکه از کامپایلر٬ scanner می‌گن.
اسم های دیگه‌ای هم داره مثل lexer و tokenizer
ولی چون توی v8 از scanner استفاده شده٬ توی این مقاله هم با این اسم می‌ریم جلو.

وقتی یک اپلیکیشن دسکتاپ درست می‌کنیم معمولا اونو کامپایل می‌کنیم و خروجی باینری اونو به کاربر می‌دیم. پس اونقدر
سرعت کامپایلر نباید اهمیت داشته باشه. اما توی جاوااسکریپت سیستم کاربر کد رو از ما میگیره و خودش کارهای
interpreting و compile
رو انجام می‌ده.
اینجاست که نوشتن یک کامپایلر سریع خیلی مهم میشه چون هرچی این کامپایلر سریع‌تر باشه٬ سایت کاربر سریع‌تر بالا میاد.

به همین علت موتور
v8
نیاز داشته که یکسری کارهای خاص انجام بده که سرعت مراحل مختلف کامپایل بالاتر بره.
کارهای خاصی که توی اسکنر انجام داده:

```text
TODO: این مفهوم خیلی خوب نرسوندم که چرا موارد زیر به سرعت کمک میکنن. باید در مورد پیچیدگی پارس کردنش هم صحبت کنم.

یا اصلا لزومی اینجا برای سرعت نداره و شاید بخوایم یک سری خاصیت های جاوا اسکریپت رو اینجا توضیح بدم که بگم 
v8
داره چطوری هندلشون میکنه
```

#### Whitespace

برای کاراکتر فاصله٬ خط جدید٬ تب و کامنت‌ها٬
یک توکن [`WHITESPACE`](https://source.chromium.org/chromium/v8/v8.git/+/edf3dab4660ed6273e5d46bd2b0eae9f3210157d:src/token.h;l=166) توی v8 تولید می‌شه.
اکثر پارسر ها میان کلا این کاراکتر هارو درنظر نمی‌گیرن و هیچ توکنی هم براشون درست نمی‌کنن ولی
v8 نیاز داره براشون توکن تولید کنه.
یکی از اصلی‌ترین دلایلش٬
[Automatic Semicolon Insertion](https://tc39.es/ecma262/#sec-automatic-semicolon-insertion)
هست که توی داکیومنت فنی
ECMAScript
اومده. توی جاوااسکریپت اجازه داریم که توی کدمون `;‍` رو حذف کنیم که این قابلیت یکسری پیچیدگی ها برامون اضافه می‌کنه. مثال زیر رو نگاه کنید:

```javascript
return;
a + b;
```

این کد به دو صورت میتونه تحلیل بشه:

**حالت اول**

```javascript
return a + b;
```

**حالت دوم**

```javascript
return;
a + b;
```

که یکیشون مقدار برمی‌گردونه و اون یکی نمیکنه.
v8 حالت دوم رو در نظر میگیره حتی اگر ممکنه اشتباه باشه چون به کد اصلی که کاربر نوشته نزدیک‌تره و برای اینکه بتونه اینکارو بکنه
باید بدونه که بعد `return` خط جدید درست شده و برای همین هم به توکن `WHITESPACE` نیاز داره.

یک مثال دیگه:

```javascript
a = b;
++c;
// after automatic semicolon insertion:
a = b;
++c;
```

**:نکته مهم** تو بعضی شرایط اینکارو رو انجام نمی‌ده
(بخاطر backward compatibility):

```javascript
a = b + c
(d + e).print();
// same as
a = b + c(d + e).print();

a = c
[0].toString();
// same as
a = c[0].toString();
```

> از نظر من درست هندل کردن
> whitespace ها توی اسکنر/پارسر ای که می‌نویسی بطوری که کد رو اسپاگتی نکنه٬
> یکی از سخت‌ترین کارهای پارسر نوشتن هست.

#### Comment

توی پایتون توی ران‌تایم میتونیم کامنت های یک تابع رو بخونیم و در واقع کامنت ها یک رشته هستن:

```python
def foo():
    """comment"""
    return
print(foo.__doc__) # comment
```

توی زبان `C#` میتونیم با انتخاب خودمون از طریق
[Reflection](https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/october/csharp-accessing-xml-documentation-via-reflection)
کامنت های از نوع Docstring رو بخونیم.

همینطور توی زبان rust کامنت های `//` ایگنور میشن ولی برای کامنت های نوع
Docstring یا `//!`
توکن درست میشه چون توی سیستم ماکرو اش میتونیم داکیومنت جنریت کنیم.

اما توی جاوااسکریپت موتور v8 برای اجرا هیچ نیازی به کامنت ها نداره برای همین بهتره که خیلی سریع از روشون بگذره.

> لازم نیست که برای سریع‌تر اجرا شدن سایتتون از این به بعد کامنت نزارید. ابزارهایی که دارید همینکار رو موقع build گرفتن براتون میکنن.
> مثلا ابزار [UglifyJs](https://github.com/mishoo/UglifyJS) که اگر به پروژه هاتون نگاه کنید٬ پیداش می‌کنید.

#### identifier scanning

توی v8 پیچیده‌ترین اما پراستفاده ترین توکن٬
توکن [`IDENTIFIER`](https://source.chromium.org/chromium/v8/v8.git/+/edf3dab4660ed6273e5d46bd2b0eae9f3210157d:src/token.h;l=147) هست
که برای
[Identifier](https://tc39.es/ecma262/#sec-identifiers)
تعریف شده داخل داکیومنت فنی
ECMAScript
تولید می‌شه. اسم توابع و متغییر ها٬ Identifier هستن که احتمالا به این موضوع برخوردید که یکسری محدودیت توی انتخاب کاراکتر ها داره:

- **ID_START:** اولین کاراکتر باید `[a-z]` ٬ `[A-Z]` ٬ `$` یا `_` باشه.
- **ID_CONTINUE:** در صورت بیشتر از یک حرفی بودن٬ بقیه کاراکتر ها یا باید *ID_START* باشن٬ یا عدد.

یکی از مهمترین دلایل این محدودیت٬ کاهش ابهام یا ambiguity توی زبان هست.
فرض کنیم کاراکتر `-` یک کاراکتر مجاز توی identifier بود. اگه کد زیر رو داشته باشیم:

```javascript
var a = 2;
var b = 1;
var a-b = 0;
if (a-b == 0) {
  console.log("A");
} else {
  console.log("B");
}
```

چنتا برداشت می‌تونیم داشته باشیم:

- **برداشت ۱:** `a-b` اشاره میکنه به مقدار داخل متغییر تعریف شده با همین نام.
- **برداشت ۲:** مقدار متغییر با نام `b` از مقدار متغییر با نام `a` کم میشه و حاصلشون با صفر مقایسه میشه.

اگر بخوایم هرکدوم از اینارو پیاده سازی کنیم
باید برای تولید هر توکن بیایم همه توکن های قبلی رو چک کنیم
و مطمینم بشیم که همچین Identifier ای رو کاربر قبلا تعریف کرده یا نه و نسبت به اون ۱ توکن درست کنیم یا ۳ تا توکن.

توی زبان جاوااسکریپت یک تابع بنام `eval` داریم که اجازه بهمون میده کد های داینامیک اجرا کنیم که باز کارو پیچیده‌تر هم میکنه.

برای اینکه بتونیم یک scanner سریع بنویسیم
هرچی کار کمتری داشته باشیم٬ کارمون هم سریع‌تر تموم می‌شه. این ابهامات پیچیدگی و درنتیجه حجم کارمون رو بیشتر میکنن و درنهایت
یک scanner کند خواهیم داشت.
حالا چون این توکن پراستفاده‌ترین توکن هست٬ اضافه کردن کوچیک‌ترین پیچیدگی هم باعث کاهش پرفرمنس میشه.

توی جاوااسکریپت چون identifier خیلی محدود هست کار اسکنر هم خیلی ساده میشه
کافیه وقتی به یک *ID_START* رسید٬ تا وقتی که کاراکتر های بعدی *ID_CONTINUE* هستن اونارو بعنوان 
identifier درنظر بگیره و نیاز نیست تحلیل خاصی هم روی تک تک کاراکتر ها انجام بده.

#### Keywords

#### Surrogate pairs

خودش داستانی داره ولی یک توضیح کوتاه اینجا بد نیست.

### Parser

[^1]: https://v8.dev/blog/scanner

<!-- [^1]: https://www.youtube.com/watch?v=xckH5s3UuX4&ab_channel=freeCodeCampTalks -->
<!-- [^2]: https://pwnbykenny.com/en/2020/06/30/v8-architectures-and-build-v8/ -->
