# V8 چیه و چطور کار می‌کنه؟

![v8-engine#@{"maxHeight":300}](v8_intro_1.png)

<br/>
<br/>
<br/>

V8 یک موتور برای اجرای جاوااسکریپت و وب‌اسمبلی هست که
در نرم‌افزار های مختلفی مثل
Google chrome
و
nodejs
استفاده می‌شه. این موتور پرفرمنس خیلی بالایی داره و دلیلش خلاقیت و تکنولوژی های جالبی هست که توش استفاده کردن.
هدف این پست اینه که بیاد این پروژه رو معرفی کنه و تا حد خوبی به جزئیات اینکه چطور کار می‌کنه٬ بپردازه.

بیایم اسکریپت زیر رو در نظر بگیریم و ببینیم
وقتی به v8 میدیمش٬ باهاش چی‌کار می‌کنه.

```js
function salam() {
  const b = "hello";
  console.log(b);
}

function askAge() {
  let age = prompt("how old are you?");
  age = parseInt(age);
  return age;
}

function validate(age) {
  if (age < 18) {
    console.log(`you are under age, come back ${18 - age} years later`);
  } else {
    console.log("hello");
  }
}

salam();
var age = askAge();
validate(age);
```

اسکریپت بالا کارش اینه که به کاربر سلام کنه، سنش رو بپرسه و اگر سنش از ۱۸ سال کمتر بود٬ پیام خطا بده.

## مرحله اول - تولید Abstract Syntax Tree

برای اینکه بشه یک کد جاوااسکریپت رو اجرا کرد٬ باید اول کد اونو به یک فرمت مخصوصی تبدیل کنیم که موتور
v8 راحت‌تر بتونه باهاش کار کنه.
این فرمت Abstract Syntax Tree یا AST هست که نشون دهنده ساختار اصلی کد هست و همه داده های اضافه مثل کامنت
و اسپیس از اون حذف شده.
AST کد خودمون همچین چیزی هست:

![TODO: create ast for the example code](https://raw.githubusercontent.com/mdevils/cst/master/docs/cst-example.png)

برای این‌که V8 این AST رو تولید کنه٬
مراحل زیر رو انجام بده:

![TODO: ](https://v8.dev/_img/scanner/overview.svg)

بریم ببینیم هر مرحله‌اش داره چیکار می‌کنه.

> توی V8 چون تا وقتی AST
> نداشته باشیم نمی‌تونیم هیچکاری انجام بدیم٬
> V8 میاد AST رو به صورت streaming تولید می‌کنه.
> خیلی ساده یعنی مثلا توی کد بالا٬ وقتی تمام کاراکتر های مورد نیازش برای تابع اول رو دریافت کرد
> یک Node توی AST ایجاد می‌کنه و اونو بر میگردونه ولی می‌گه هنوز کارش تموم نشده.
> اینطوری V8 میتونه مثلا تابع اول رو اجرا کنه با اینکه هنوز بقیه کد رو
> parse نکرده.

### Scanner ـ [^1]

کامپایلر هر زبان برنامه‌نویسی برای اینکه بتونه خروجی تولید کنه٬ باید اول بتونه کدهای شمارو بفهمه. اولین قدم فهمیدن٬
بررسی رشته ورودی‌ای هست که بهش دادین. اگه کد زیر رو داشته باشیم:

```javascript
if (allow == true) {
  console.log("welcome");
}
```

کامپایلر باید توالی کاراکتر های ورودی رو بخونه و اونو تبدیل به توکن کنه که کار فهمیدن راحت‌تر بشه:

![scanner example](v8_scanner_1.png)

فرض کنیم تصویر بالا٬ ساده شده یک scanner برای جاوااسکریپت هست.
کد خودمون رو دادیم بهش و اون توی خروجی بهمون یک توالی از token ها داده.
کار کردن با این توکن ها برای فهم کد به مراتب راحت‌تر از مستقیم کار کردن روی کاراکتر هاست.
مثلا بعدا اگر بخوایم بفهمیم که آیا کاربر اینجا یک شرط نوشته باید دنبال یک الگو از توکن های پشت سر هم باشیم مثلا:

`[..., IF, PARAN_OPEN, IDENT, PARAN_CLOSE, ...]`
یا
`[..., IF, PARAN_OPEN, KEYWORD, PARAN_CLOSE, ...]`

که پیدا کردن این الگو به کمک لیست توکن ها خیلی ساده‌تر هست. این قسمت یک نکته مهمی که داره اینه که ممکنه همچین ورودی داشته باشیم:

```javascript
if if if true
```

که توی جاوااسکریپت معنی نمیده ولی
scanner
باز هم توالی توکن
`[IF, IF, IF, TRUE]`
رو تولید می‌کنه و تایید اعتبار ترکیب درست توکن ها کنار هم توی مرحله بعد یعنی پارسر انجام می‌شه.

> نکته: داخل scanner بالا کاراکتر های اضافه مثل فاصله و خط جدید هم حذف شدن ولی لزوما هر کامپایلری این کار رو توی این مرحله انجام نمیده.

به این تیکه از کامپایلر٬ scanner می‌گن.
اسم های دیگه‌ای هم داره مثل lexer و tokenizer
ولی چون توی v8 از scanner استفاده شده٬ توی این مقاله هم با این اسم می‌ریم جلو.

وقتی یک اپلیکیشن دسکتاپ درست می‌کنیم معمولا اونو کامپایل می‌کنیم و خروجی باینری اونو به کاربر می‌دیم. پس اونقدر
سرعت کامپایلر نباید اهمیت داشته باشه. اما توی جاوااسکریپت کاربر کد رو از ما میگیره و خودش کارهای
interpreting و compile
رو انجام می‌ده.
اینجاست که نوشتن یک کامپایلر سریع خیلی مهم میشه چون هرچی این کامپایلر سریع‌تر باشه٬ سایت کاربر سریع‌تر بالا میاد.

به همین علت موتور
v8
نیاز داشته که یکسری کارهای خاص انجام بده که سرعت مراحل مختلف کامپایل بالاتر بره.
کارهای خاصی که توی اسکنر انجام داده:

#### Whitespace

برای کاراکتر فاصله٬ خط جدید٬ تب و کامنت‌ها٬
یک توکن [`WHITESPACE`](https://source.chromium.org/chromium/v8/v8.git/+/edf3dab4660ed6273e5d46bd2b0eae9f3210157d:src/token.h;l=166) توی v8 تولید می‌شه.
اکثر پارسر ها میان کلا این کاراکتر هارو درنظر نمی‌گیرن و هیچ توکنی هم براشون درست نمی‌کنن ولی
v8 نیاز داره براشون توکن تولید کنه.
یکی از اصلی‌ترین دلایلش٬
[Automatic Semicolon Insertion](https://tc39.es/ecma262/#sec-automatic-semicolon-insertion)
هست که توی داکیومنت فنی
ECMAScript
اومده. توی جاوااسکریپت اجازه داریم که توی کدمون `;‍` رو حذف کنیم. این قابلیت یکسری پیچیدگی ها اضافه می‌کنه. مثال زیر رو نگاه کنید:

```javascript
return;
a + b;
```

این کد به دو صورت میتونه تحلیل بشه:

**حالت اول**

```javascript
return a + b;
```

**حالت دوم**

```javascript
return;
a + b;
```

که یکیشون مقدار برمی‌گردونه و اون یکی نمیکنه.
v8 حالت دوم رو در نظر میگیره حتی اگر ممکنه اشتباه باشه چون به کد اصلی که کاربر نوشته نزدیک‌تره و برای اینکه بتونه اینکارو بکنه
باید بدونه که بعد `return` خط جدید درست شده و برای همین هم به توکن `WHITESPACE` نیاز داره.

یک مثال دیگه:

```javascript
a = b;
++c;
// after automatic semicolon insertion:
a = b;
++c;
```

**:نکته مهم** تو بعضی شرایط اینکارو رو انجام نمی‌ده
(بخاطر backward compatibility):

```javascript
a = b + c(d + e).print();
// same as
a = b + c(d + e).print();

a = c[0].toString();
// same as
a = c[0].toString();
```

> از نظر من درست هندل کردن
> whitespace ها توی اسکنر/پارسر ای که می‌نویسی بطوری که کد رو اسپاگتی نکنه٬
> یکی از سخت‌ترین کارهای پارسر نوشتن هست.

##### حاشیه باز: زبان های دیگه هم کامنت هارو skip می‌کنن؟

توی پایتون توی ران‌تایم میتونیم کامنت های یک تابع رو بخونیم و در واقع کامنت ها یک رشته هستن:

```python
def foo():
    """comment"""
    return
print(foo.__doc__) # comment
```

توی زبان `C#` میتونیم با انتخاب خودمون از طریق
[Reflection](https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/october/csharp-accessing-xml-documentation-via-reflection)
کامنت های از نوع Docstring رو بخونیم.

همینطور توی زبان rust کامنت های `//` ایگنور میشن ولی برای کامنت های نوع
Docstring یا `//!`
توکن درست میشه چون توی سیستم ماکرو اش میتونیم داکیومنت جنریت کنیم.

اما توی جاوااسکریپت موتور v8 برای اجرا هیچ نیازی به کامنت ها نداره برای همین بهتره که خیلی سریع از روشون بگذره.

> لازم نیست که برای سریع‌تر اجرا شدن سایتتون از این به بعد کامنت نزارید. ابزارهایی که دارید همینکار رو موقع build گرفتن براتون میکنن. 
> مثلا ابزار [UglifyJs](https://github.com/mishoo/UglifyJS) که اگر به پروژه هاتون نگاه کنید٬ پیداش می‌کنید.

_حاشیه بسته_

#### identifier scanning

#### Internalizing minified identifiers

#### Keywords

#### Surrogate pairs

خودش داستانی داره ولی یک توضیح کوتاه اینجا بد نیست.

### Parser

[^1]: https://v8.dev/blog/scanner

<!-- [^1]: https://www.youtube.com/watch?v=xckH5s3UuX4&ab_channel=freeCodeCampTalks -->
<!-- [^2]: https://pwnbykenny.com/en/2020/06/30/v8-architectures-and-build-v8/ -->
