وقتی پارسر به یک تابع می‌رسه بجای اینکه بیاد کامل پارسش کنه٬ میاد حداقل کار رو انجام میده مثل چک کردن
سینتکس و استخراج کردن متادیتا مورد نیازی که توابع بیرونی اون لازم دارن که صداش بزنن. مثل اسمش.
وقتی این فانکشن کامل پارس و کامپایل می‌شه که ما اونو صداش بزنیم.
این کار باعث میشه که توابع مورد نیاز برای لود اولیه یک سایت توی اولویت قرار بگیرن و استارتاپ خیلی سریع‌تر بشه.

TODO: مثال همون درخت pre-parse با کد توی یک عکس

اصلی ترین چالش برای pre-parser، تخصیص حافظه برای متغییر هاست.
فانکشن ها توی v8 با stack صدا زده میشن تا پرفرمنس بهتری داشته باشن.

##### یک پرانتز بزرگ برای اینکه بفهمیم یعنی چی این stack و چرا باعث پرفرمنس بهتری میشه؟

TODO:

به کد زیر نگاه کنید:

```javascript
function f(a, b) {
  const c = a + b;
  return c;
}

function g() {
  return f(1, 2);
}
```

TODO: aval `rip` hast ba arugments ya bar ax?

وقتی توی تابع `g()` می‌خوایم تابع `f()` رو صدا بزنیم٬ اول میایم توی
استک `this` که اینجا `globalThis` رو پوش می‌کنیم. <Note>دلیل اینکه مقدار this برابر هست با globalThis بخاطر اینه که این تابع، یک تابع sloppy هست. اینجا بیشتر می‌تونید در موردش بخونید: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode</Note>
سپس آرگومان های داده شده که اینجا `1` و `2` هستن، در نهایت هم توی یک پوینتر مخصوص به نام `rip` باید آدرس جایی که باید بهش برگردیم رو بریزیم.
حالا می‌تونیم بریم داخل تابع `f()`. وقتی توی تابع به یک `return` رسیدیم کافیه که استک رو تا اولین مقداری که پوش کردیم، پاپ کنیم، نتیجه تابع رو توی استک
پوش کنیم و درنهایت با استفاده از `rip` به تابع قبلیمون یا همون `g()` برگردیم.<Note>همه توابع که اجراشون با خطا همراه نباشه به صورت ضمنی یک مقداری رو بر می‌گردونن حتی اگه هیچ return ای داخلش ننوشته باشید.</Note>

![TODO:](https://v8.dev/_img/preparser/stack-1.svg)

حالا برگردیم به مشکل قبلی، چرا این برای pre-parser مشکل سازه؟ به کد زیر دقت کنید:

```javascript
function make_f(d) { // ← declaration of `d`
  return function inner(a, b) {
    const c = a + b + d; // ← reference to `d`
    return c;
  };
}

const f = make_f(10);

function g() {
  return f(1, 2);
}
```

تفاوت این کد با کد قبلی استفاده از `closure` هست. توابعی که یکسری رفرنس به مقادیری دارن که از ورودی بهشون داده نشده.
این مقادیر توی v8 توی یک چیزی به نام `context` به توابع موقع صدا زدن پاس داده میشه.