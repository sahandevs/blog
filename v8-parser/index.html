<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link href="https://fonts.googleapis.com/css?family=Source Code Pro" rel="stylesheet"/><style data-href="/styles.41c365c0c993c6df84a7.css" data-identity="gatsby-global-css">:root{--lr-padding:10px;--border-radius:8px;--primary-color-active:#ff7e14;--primary-color-inactive:#ffd1ac;--secondary-color:#fffcf9;--anim-duration:300ms;--paragraph-width:calc(min(760px, 100%));--code-width:min(100%,calc(var(--paragraph-width) + 12%));--paragraph-padding:calc(var(--code-width)/2 - var(--paragraph-width)/2);font-size:16px}.footnotes,.main-container h1,.text,a,em,h2,h3,h4,h5,h6,li,p,ul{direction:rtl;font-family:Vazir,monospace,Source Code Pro!important;line-height:1.6}.main-container h1,h2,h3,h4,h5,h6{padding-left:var(--paragraph-padding);padding-right:var(--paragraph-padding)}.text a{overflow-wrap:anywhere}.footnotes li{color:#5c6e74;font-size:.8rem!important}.main-container-wrapper{align-items:center;display:flex;flex-direction:column;width:100%}.main-container p{margin:0}a{text-decoration:none}a,a:hover{color:var(--primary-color-active)}a:hover{text-decoration:underline}.main-container{padding-top:1rem;width:var(--code-width)}.main-container img{display:block;margin-left:auto;margin-right:auto;max-height:500px;max-width:80%}.main-container .img-container{max-width:100%}@media screen and (max-width:768px){:root{--lr-padding:10%}}@media screen and (max-width:375px){:root{--lr-padding:5%}.main-container{margin-top:0;padding-top:0!important}.main-container h1{margin-top:10px}.main-container blockquote{margin:25px 0 0}.main-container img{max-width:100%;vertical-align:top}.main-container .img-container{overflow-x:auto}}.main-container li{font-size:1.2rem;margin-left:var(--paragraph-padding);margin-right:var(--paragraph-padding);margin-top:.6rem;padding:0;text-align:justify}.main-container p,.text{font-size:1.2rem;padding-left:var(--paragraph-padding);padding-right:var(--paragraph-padding);text-align:justify}.main-container blockquote .text{--h-space:10px;--v-space:4px;background-color:#e7e7e7;border-radius:var(--border-radius);border-right:5px solid var(--primary-color-inactive);margin-left:calc(var(--paragraph-padding)*1.3);margin-right:calc(var(--paragraph-padding)*1.3);padding:var(--v-space) var(--h-space);transition:border-right var(--anim-duration)}.main-container blockquote .text:hover{border-right-color:var(--primary-color-active)}.resources .text{direction:ltr;font-size:.8rem;text-align:start}.main-container code{background-color:#f1f1f1;border-radius:var(--border-radius);direction:ltr!important;font-size:1.1rem;padding-left:6px;padding-right:6px;text-align:left;white-space:nowrap}.playground-button{background-color:var(--primary-color-active);border-bottom-left-radius:var(--border-radius);padding:0 5px;position:absolute;right:0;top:0}.playground-button a{color:#fff;font-size:.8rem;margin:0}.playground-button a:hover{text-decoration:none}code[class*=language-],pre[class*=language-]{color:#5c6e74;direction:ltr;font-family:Source Code Pro,Andale Mono,Ubuntu Mono,monospace;font-size:1rem;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;text-shadow:none;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-]::mozselection,code[class*=language-]::selection,pre[class*=language-]::mozselection,pre[class*=language-]::selection{background:#b3d4fc;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{background:var(--secondary-color);border:1px solid var(--primary-color-inactive);border-radius:var(--border-radius);margin:.5em 0;overflow:auto;padding:.8em;transition:border var(--anim-duration)}pre[class*=language-]:hover{border:1px solid var(--primary-color-active)}:not(pre)>code[class*=language-]{background:#f9f2f4;border-radius:.3em;color:#db4c69;padding:.1em .3em}.namespace{opacity:.7}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#999}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{background:#fff;color:#a67f59}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}pre[data-line]{position:relative}pre[class*=language-]>code[class*=language-]{position:relative;z-index:1}.line-highlight{background:#f7ebc6;box-shadow:inset 5px 0 0 #f7d87c;left:0;line-height:inherit;margin-top:1em;padding-bottom:inherit;padding-left:0;padding-right:0;padding-top:inherit;pointer-events:none;position:absolute;right:0;white-space:pre;z-index:0}.footnotes,.post-list-container h1,.text,a,em,h2,h3,h4,h5,h6,li,p,ul{font-family:Vazir,monospace,Source Code Pro!important;line-height:1.6;margin:0;padding:0}.post-list-container ul{list-style-type:circle;padding:0}.post-list-container li a{color:#121212;-webkit-text-decoration-style:dotted;text-decoration-style:dotted}.post-list-container li{margin-top:16px}.category-container .badge{background-color:var(--primary-color-active);border-radius:5px;color:#fff;margin-left:5px;padding-left:4px;padding-right:4px}.post-list-container{direction:rtl;display:flex;flex-direction:row;flex-wrap:wrap;padding:3rem}.category-container{margin:2rem 1rem;width:calc(50% - 2rem)}.category-container .hr{background-color:var(--primary-color-active);border-radius:5px;height:5px;margin-bottom:1rem;margin-top:.1rem;width:40%}@media screen and (max-width:425px){.category-container{width:100%}.post-list-container{padding:1rem}}.social{display:flex;flex-direction:row;font-family:Source Code Pro!important;font-size:.9rem;justify-content:center;margin-top:20px;width:100%}.social a{color:grey!important;opacity:.6;transition:.2s}.social a:hover{opacity:1}.social p{margin-left:10px;margin-right:10px}</style><meta name="generator" content="Gatsby 4.1.3"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">Parser چیه و توی v8 چطوری کار می‌کنه؟ - قسمت ۲</title><meta data-react-helmet="true" charSet="utf-8"/><meta data-react-helmet="true" property="og:title" content="Parser چیه و توی v8 چطوری کار می‌کنه؟ - قسمت ۲"/><meta data-react-helmet="true" property="og:site_name" content="Sahand&#x27;s blog"/><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link as="script" rel="preload" href="/webpack-runtime-eb92277a3bb70a1028db.js"/><link as="script" rel="preload" href="/framework-02d188296aa8e09a771c.js"/><link as="script" rel="preload" href="/app-b509bedfbb4c87ecc04a.js"/><link as="script" rel="preload" href="/b3cb720b120fadd5cd62c0f493389da7ab972379-9ace7c48e7e7a825d7a3.js"/><link as="script" rel="preload" href="/component---src-pages-v-8-parser-mdx-2d45c7f76e544a018b51.js"/><link as="fetch" rel="preload" href="/page-data/v8-parser/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="main-container-wrapper"><div class="main-container"><h1>Parser چیه و توی v8 چطوری کار می‌کنه؟ - قسمت ۲</h1><div class="text">پارس کردن مرحله‌ای هست که سورس کد شما تبدیل به یک فرمت میانی قابل استفاده توسط کامپایلر می‌شه. چون پارس کردن در مسیر اصلی پردازش شدن یک وبسایت انجام می‌شه و روی لود شدن اولیه اون تاثیر مستقیم داره، خوبه که هیچ کار اضافه‌ای انجام ندیم.
همه تابع های کد شما برای استارتاپ و اجرای اولیه سایت شما لازم نیستن.
مثلا اگه از فریمورک react استفاده می‌کنید، کامپوننت های شما فانکشن اند و لزوما توی یک صفحه همه کامپوننت ها دیده نمی‌شن
.اگه بخوایم همه کد رو همون اول پارس و کامپایل کنیم (کامپایل اینجا یعنی تبدیل AST به bytecode موتور ignition v8 هست)،
منابع سیستم رو به خوبی استفاده نکردیم.</div><div class="text">مرورگرها برای بهتر کردن این مسئله٬ کد هارو به صورت lazy پارس می‌کنن و AST ای تولید نمی‌کنن. v8 علاوه بر این میاد کد رو pre-parse هم می‌کنه.</div><h3>Parse کردن چی هست؟</h3><div class="text">توی مرحله قبل یعنی <a href="/v8" dir="ltr">scanning</a> وقتی کدو بهش میدیم یک لیست یک سطحی از توکن ها رو بهمون میده. تو مرحله parse کردن باید اونارو تبدیل به یک درخت مثل درخت زیر کنیم:</div><div class="text"><a class="img-container" href="/images/v8_ast_1.png" target="_blank"><img src="/images/v8_ast_1.png" alt="example code AST" dir="ltr"/></a></div><div class="text">برای اینکار باید بدونیم چه توکن هایی کنار هم چه معنی ای میدن. مثلا برای یک assignment خیلی ساده حالت های زیر ممکنه:</div><div style="position:relative"><pre class="prism-code language-javascript"><div class="token-line"><span class="token plain">a </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">a</span><span class="token punctuation">.</span><span class="token property-access">b</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">a</span><span class="token punctuation">.</span><span class="token property-access">c</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token string">&quot;&quot;</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">a </span><span class="token operator">=</span><span class="token plain"> a</span><span class="token punctuation">;</span></div></pre></div><div class="text">برای بهتر درک کردن این الگو ها بهتره اونارو توی فرمت یک گرامر بنویسم. مثل:</div><div style="position:relative"><pre class="prism-code language-text"><div class="token-line"><span class="token plain">Assignment : IDENT | Member EQUAL STRING_LITERAL | NUMBER_LITERAL | IDENT | Member SEMI_COLON?</span></div><div class="token-line"><span class="token plain">Member : IDENT . IDENT Member?</span></div></pre></div><div class="text">بیایم گرامر بالا رو باز کنیم.
دو موجودیت اصلی اون non-terminal و terminal ها هستن.
terminal ها قوانینی هستن که نمیشه برشون داشت
و جایگزینی براشون گذاشت مثل توکن ها که توی مثال بالا terminal ها تمام حروفشون بزرگه.
non-terminal ها هم قوانینی هستن که میشه برشون داشت بجاش جایگزین گذاشت تا در نهایت به terminal برسیم.
مثل <code dir="ltr">Assignment</code> و <code dir="ltr">Member</code>.</div><div class="text">کاراکتر <code dir="ltr">|</code> معنی یا رو می‌ده
و مثلا توی گرامر بالا وقتی داریم <code dir="ltr">IDENT | Member</code> معنیش این می‌شه که ما
می‌تونیم اینجا یا یک ترمینال <code dir="ltr">IDENT</code> داشته باشیم یا یک non-terminal <code dir="ltr">Member</code>. کاراکتر <code dir="ltr">?</code> هم مشخص می‌کنه
که این قسمت از قانون optional هست.
همینطور قوانین می‌تونن به خودشون برگردن. به تعریف <code dir="ltr">Member</code>
نگاه کنید. با اینطور نوشتن قانون حالت های زیر رو می‌تونیم پشتیبانی کنیم:</div><div style="position:relative"><pre class="prism-code language-text"><div class="token-line"><span class="token plain">a.a , a.a.a, a.b.a.c , ...</span></div></pre></div><div class="text">حالا که این گرامر رو داریم نوشتن کد پارسرمون یجورایی ساده می‌شه. فقط کافیه همون قوانین رو مستقیم تبدیل به کدشون کنیم. به شبه کد زیر برای پارس کردن یک <code dir="ltr">Member</code> با گرامر بالا دقت کنید:</div><div style="position:relative"><pre class="prism-code language-javascript"><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">parseMember</span><span class="token punctuation">(</span><span class="token parameter">tokens</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">tokens</span><span class="token punctuation">.</span><span class="token property-access">length</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain"> </span><span class="token number">3</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> t1 </span><span class="token operator">=</span><span class="token plain"> tokens</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">t1</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token plain"> </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token string">&quot;IDENT&quot;</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> t2 </span><span class="token operator">=</span><span class="token plain"> tokens</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">t2</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token plain"> </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token string">&quot;DOT&quot;</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> t3 </span><span class="token operator">=</span><span class="token plain"> tokens</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">t3</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token plain"> </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token string">&quot;IDENT&quot;</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">let</span><span class="token plain"> chain </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">t1</span><span class="token punctuation">,</span><span class="token plain"> t2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> rest </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">parseMember</span><span class="token punctuation">(</span><span class="token plain">tokens</span><span class="token punctuation">.</span><span class="token method function property-access">rest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">if</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">rest </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    chain </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token plain">chain</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token spread operator">...</span><span class="token plain">rest</span><span class="token punctuation">.</span><span class="token property-access">chain</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    type</span><span class="token operator">:</span><span class="token plain"> </span><span class="token string">&quot;Member&quot;</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    chain</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><h3>مرحله pre parsing چیه؟</h3><div class="text">وقتی پارسر به یک تابع می‌رسه بجای اینکه بیاد کامل پارسش کنه، میاد حداقل کار رو انجام میده مثل چک کردن سینتکس و استخراج کردن متادیتا مورد نیازی که توابع بیرونی لازم دارن که صداش بزنن. مثل اسمش. وقتی این فانکشن کامل پارس و کامپایل می‌شه که ما اونو صداش بزنیم. این کار باعث میشه که توابع مورد نیاز برای لود اولیه یک سایت توی اولویت قرار بگیرن و استارتاپ خیلی سریع‌تر بشه.</div><div class="text">اصلی ترین چالش برای pre-parser، تخصیص حافظه برای متغییر هاست. فانکشن ها توی v8 با stack صدا زده میشن تا پرفرمنس بهتری داشته باشن.</div><div class="text">یعنی چی فانکشن ها با استفاده از stack صدا زده میشن؟</div><div class="text">برای فهمیدن این موضوع باید بفهمیم مموری یک برنامه از چه قسمت هایی تشکیل می‌شه. هر برنامه ای محیط مموری مثل شکل زیر رو داره:</div><div class="text"><a class="img-container" href="/images/v8-parser-memory-layout.png" target="_blank"><img src="/images/v8-parser-memory-layout.png" alt="program memory layout" dir="ltr"/></a></div><br/><br/><div class="text">آخر این مموری یک سری داده های ثابت (با اندازه ثابت) هستند که در حالت عادی دولوپر نمی تونه اونارو تغییر بده.
این قسمت شامل کد برنامه و یک سری داده static هستند.</div><div class="text">بعد از این داده ها یک منطقه مموری قابل گسترش قرار داره که به اون heap میگن.
Heap به سمت اول مموری گسترش پیدا می‌کنه.</div><div class="text">سمت آخر و اول یعنی اگر مثلا یک معماری داشته باشیم که اشاره‌گرش نهایتن بتونه به آدرس x اشاره کنه و اولین آدرس،
آدرس ۰ باشه، Heap از <code dir="ltr">x - sizeof(static data)</code> شروع می‌شه.
اگر یک داده با اندازه ۸ بیت داشته باشیم بخوایم اونو بریزیم توی Heap
باید ابتدا ۱ بایت حافظه براش بگیریم (allocate) کنیم.
اگر این تخصیص رو انجام بدیم شروع این رنج حافظه <code dir="ltr">heap_start - 1</code> و آخر اون
<code dir="ltr">heap_start</code> می‌شه. اگه داده بعدیمون ۱۶ بیت باشه شروعش <code dir="ltr">heap_start - 3</code> و
پایانش اول داده اولمون هست که میشه <code dir="ltr">heap_start - 1</code> و تا آخر…</div><div class="text">قسمت دیگه قابل تغییر این مموری استک هست که باید فاصله‌ای
از شروع مموری برنامه شروع میشه و به سمت آخر رشد می‌کنه.</div><div class="text">فرق این دوتا مموری اینه که توی استک فقط می‌تونیم
به آخر استک چیزی اضافه کنیم و اگه بخوایم
یک مقدار رو پاک کنیم، باید تمام مقدار هایی
که قبلش اضافه کردیم هم پاک کنیم.(همون ساختار داده stack) مثل چنتا ماشین توی یک کوچه تنگ که اگه ماشین آخری بخواد
بیاد بیرون باید اول همه
ماشین های جلوش بیان بیرون.جدا از اون همه داده
ها باید موقع کامپایل سایز مشخصی داشته باشن.
اما Heap این محدودیت رو نداره و می تونیم با هرالگویی و سایزی دیتا اضافه کنیم یا کم کنیم یا جابجا کنیم.
(قطعا تا جایی که مموری کافی داشته باشیم) حالا چرا stack از heap سریع‌تر هست؟</div><div class="text">در اصل همین
محدودیت توی نحوه دسترسی به داده (Access pattern) که داخل stack هست باعث میشه که الگوی دسترسی قابل پیش‌بینی داشته باشه (که این الگو خطی هست)
و این در نهایت باعث میشه که بتونیم از CPU Cache استفاده زیادی ببریم و همینطور CPU (و کامپایلرها)
می‌تونن با پیش‌بینی های خودشون از برنامه نسبت به فرض الگوی دسترسی که داریم، برنامه مارو بهینه‌تر اجرا کنند.
اما چون Heap الگوی مشخص‌ای برای دسترسیش مشخص نیست، این بهینه سازی ها خیلی سخت‌تر انجام می‌شن.
در اصل اگر برنامه‌ها بخوان بصورت پویا به یک داده‌ای داخل Heap دسترسی داشته باشن باید حتما از
stack استفاده کنن. معمولا یک ساختار داده هایی هستن که بهشون Proxy میگن. مثلا یک چیزی مثل استرینگ که
سایز مشخصی نداره ساختار داده‌ای
مثل شکل زیر داره:</div><div class="text"><a class="img-container" href="/images/v8-parser-proxy-struct-string.png" target="_blank"><img src="/images/v8-parser-proxy-struct-string.png" alt="proxy struct" dir="ltr"/></a></div><div class="text">یک struct با اندازه ثابت داره که داخلش
یک پوینتر و یک اندازه قرار داره. این پوینتر به یک قسمتی از heap اشاره می‌کنه (کاراکتر اول) و می‌تونیم با اضافه کردن اندازه به این
پوینتر مشخص کنیم
پایان این رشته توی Heap کجاست. این struct داخل
استک قرار می‌گیره که یک Proxy struct هست و با استفاده از اطلاعات این پراکسی می‌تونیم خود رشته رو از Heap بخونیم.</div><div class="text">حالا برگردیم به صدا زدن فانکشن ها با استفاده از stack. توابع با قرارداد های مختلفی صدا زده می‌شن که زیاد نمی‌خوام
بهشون بپردازم ولی خیلی کلی وقتی ما یک تابع رو
صدا می‌زنیم باید به یک طریقی پارامتر هارو برای اون تابع
بفرستیم تا اون بتونه ازشون استفاده کنه. فرض کنیم یک
تابع داریم که دوتا ورودی عدد می‌گیره.
برای صدا زدن این تابع اول میایم دوتا پارامتر رو به stack اضافه می‌کنیم و وارد تابع می‌شیم. تابع میدونه که دوتا ورودی داره و موقع شروع اجراش
میدونه از کجا شروع شده پس میتونه با خوندن
دوتا المان آخری stack پارامتر هارو بخونه.</div><div class="text">حالا کار تابع تموم شده ‌می‌خواد برگرده.
کافیه دو المان آخر
(و همه دیتا های لوکالی که داخل خودش درست کرده)‌ رو pop کنه مقدار return
رو توی استک پوش کنه و برگرده به تابع قبلی. اینطوری تابع قبلی فقط یک
داده اضافه داره و
اون همون مقدار return value تابعی ای هست که داخلش صدا شده.
حالا توی جاوااسکریپت
اگه ساختار داده‌ای نداشته باشیم که نیاز به Heap و proxy struct داشته باشه کافیه فقط با همین استک به فانکشن های مختلف پاسشون بدیم.
مثلا یک عدد رو می‌تونیم پوش کنیم توی استک.</div><div class="text">بعضی وقتا هم نمی‌تونیم اینکارو کنیم مثلا اگه بخوایم یک استرینگ پاس بدیم به یک تابع باید اول توی Heap
اونو ذخیره کنیم
و یک proxy struct یا پوینتر تنها داشته باشیم که
(سایز ثابتی داره)‌ و اون پراکسی
رو به استک پوش کنیم. توی این حالت از Heap برای پاس دادن داده استفاده کردیم که همینطور که گفتیم پرفرمنس بدتری نسبت به استفاده مستقیم از استک داره.</div><div class="text">برای فهم بهتر به مثال زیر نگاه کنیم:</div><div style="position:relative"><pre class="prism-code language-javascript"><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token parameter punctuation">,</span><span class="token parameter"> b</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> c </span><span class="token operator">=</span><span class="token plain"> a </span><span class="token operator">+</span><span class="token plain"> b</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> c</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><div class="text">وقتی توی تابع <code dir="ltr">g()</code> می‌خوایم تابع <code dir="ltr">f()</code> رو صدا بزنیم٬ اول میایم توی استک <code dir="ltr">this</code> که اینجا <code dir="ltr">globalThis</code>
هست رو پوش می‌کنیم. سپس آرگومان های داده شده که اینجا <code dir="ltr">1</code> و <code dir="ltr">2</code> هستن، در نهایت هم توی یک پوینتر مخصوص به نام <code dir="ltr">rip</code> باید آدرس جایی که باید بهش برگردیم رو بریزیم.
حالا می‌تونیم بریم داخل تابع <code dir="ltr">f()</code>. وقتی توی تابع به یک <code dir="ltr">return</code> رسیدیم کافیه که استک رو تا اولین مقداری که پوش کردیم، پاپ کنیم، نتیجه تابع رو توی استک پوش کنیم و درنهایت با استفاده از <code dir="ltr">rip</code> به تابع قبلیمون یا همون <code dir="ltr">g()</code> برگردیم.</div><div class="text"><a class="img-container" href="https://v8.dev/_img/preparser/stack-1.svg" target="_blank"><img src="https://v8.dev/_img/preparser/stack-1.svg" alt="stack-1" dir="ltr"/></a></div><div class="text">حالا برگردیم به مشکل قبلی، چرا این برای pre-parser مشکل سازه؟ به کد زیر دقت کنید:</div><div style="position:relative"><pre class="prism-code language-javascript"><div class="token-line"><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">make_f</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// ← declaration of `d`</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">inner</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token parameter punctuation">,</span><span class="token parameter"> b</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> c </span><span class="token operator">=</span><span class="token plain"> a </span><span class="token operator">+</span><span class="token plain"> b </span><span class="token operator">+</span><span class="token plain"> d</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">// ← reference to `d`</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> c</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> f </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">make_f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><div class="text">تفاوت این کد با کد قبلی استفاده از <code dir="ltr">closure</code> هست. توابعی که یکسری رفرنس به مقادیری دارن که از ورودی بهشون داده نشده.
این مقادیر توی v8 توی یک چیزی به نام <code dir="ltr">context</code> به توابع موقع صدا زدن پاس داده میشه.
توی این مثال وقتی <code dir="ltr">make_f</code> رو صدا می‌زنیم یک تابع می‌سازیم که به ورودی که اول بهش دادیم (۱۰) نیاز داره.
این تابع معلوم نیست کی قراره صدا زده بشه پس
نمی‌تونیم توی استک نگهش داریم. پس مجبوریم ببریمش روی هیپ.
توی این حالت هایی که یک تابع یک تابع دیگه‌ای رو تولید می‌کنه
که تابع داخلی به یک سری چیز از بیرون رفرنس داره بهش می‌گن closure و context یک proxy structure
ای هست که این رفرنس هارو نگه می‌داره و
کنار این closure نگه‌داری می‌شه تا هر وقت خواستیم این تابع رو صدا بزنیم، این context رو هم بهش بدیم:</div><div class="text"><a class="img-container" href="https://v8.dev/_img/preparser/stack-2.svg" target="_blank"><img src="https://v8.dev/_img/preparser/stack-2.svg" alt="stack-2" dir="ltr"/></a></div><div class="text">چون داریم pre-parse می‌کنیم میخوایم خیلی سریع از body تابع بگذریم و همین‌جا که نمی‌دونیم باید موقع صدا زدن چه آرگومان هایی رو ببریم روی Heap چالش درست می‌کنه. اگه بخوایم همه ورودی های یک تابع رو ببریم روی Heap که خیلی رو پرفرمنس توابعی تاثیر میزاره که ورودی های ساده‌ای مثل عدد می‌گیرن. اینجا توی v8 باید یکم از سرعتی که pre-parser داره بزنیم و حداقل variable هارو track کنیم. چطور اینکارو بهینه انجام می‌ده؟ یک پست جدای خودش رو لازم داره و بیشتر رفتن تو detail این قسمت ممکنه خسته کننده بشه. احتمالا یک پست جدا باز این سری براش درست کنم و قسمت بعدی بریم وارد قسمت های جذاب‌تر v8 بشیم.
مثل کامپایلر اون. توی <a href="/v8-ignition" dir="ltr">قسمت بعدی</a> نگاه می‌کنیم به interpreter ignition که داخل v8 وجود داره. اولین قسمتی که کد مارو واقعا اجرا می‌کنه.</div><hr/><h3>منابع</h3><div dir="ltr" class="resources"><div class="text">[<!-- -->1<!-- -->]<!-- -->: <a href="https://v8.dev/blog/preparser" dir="ltr">https://v8.dev/blog/preparser</a></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/v8-parser/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-d69664561c90ab43065f.js"],"app":["/app-b509bedfbb4c87ecc04a.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-f320ba337d28ea2b66b6.js"],"component---src-pages-context-magic-mdx":["/component---src-pages-context-magic-mdx-7d815f0fda3b761b850a.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-f1114d5558dbd6ea36c1.js"],"component---src-pages-ratelimit-p-1-mdx":["/component---src-pages-ratelimit-p-1-mdx-e6a2f79308b17ab1af8e.js"],"component---src-pages-ratelimit-p-2-mdx":["/component---src-pages-ratelimit-p-2-mdx-d396b307766e78b1a114.js"],"component---src-pages-usb-switcher-mdx":["/component---src-pages-usb-switcher-mdx-3ae427c094674b038772.js"],"component---src-pages-v-8-ignition-mdx":["/component---src-pages-v-8-ignition-mdx-81a18377b88f88e9a629.js"],"component---src-pages-v-8-jit-mdx":["/component---src-pages-v-8-jit-mdx-524980411d4111a105cd.js"],"component---src-pages-v-8-mdx":["/component---src-pages-v-8-mdx-a3e700e62668fa47202f.js"],"component---src-pages-v-8-parser-mdx":["/component---src-pages-v-8-parser-mdx-2d45c7f76e544a018b51.js"]};/*]]>*/</script><script src="/polyfill-d69664561c90ab43065f.js" nomodule=""></script><script src="/component---src-pages-v-8-parser-mdx-2d45c7f76e544a018b51.js" async=""></script><script src="/b3cb720b120fadd5cd62c0f493389da7ab972379-9ace7c48e7e7a825d7a3.js" async=""></script><script src="/app-b509bedfbb4c87ecc04a.js" async=""></script><script src="/framework-02d188296aa8e09a771c.js" async=""></script><script src="/webpack-runtime-eb92277a3bb70a1028db.js" async=""></script></body></html>